<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zxh23682.github.io</id>
    <title>zxh23682 的博客</title>
    <updated>2020-11-18T11:57:16.081Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zxh23682.github.io"/>
    <link rel="self" href="https://zxh23682.github.io/atom.xml"/>
    <subtitle>一个蒟蒻OIer</subtitle>
    <logo>https://zxh23682.github.io/images/avatar.png</logo>
    <icon>https://zxh23682.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, zxh23682 的博客</rights>
    <entry>
        <title type="html"><![CDATA[C++ 测评bat文件模板]]></title>
        <id>https://zxh23682.github.io/post/c-ce-ping-bat-wen-jian-mo-ban/</id>
        <link href="https://zxh23682.github.io/post/c-ce-ping-bat-wen-jian-mo-ban/">
        </link>
        <updated>2020-11-18T10:16:20.000Z</updated>
        <content type="html"><![CDATA[<pre><code>@echo off
title TestData - carry
if &quot;%1&quot;==&quot;&quot; goto loop
copy carry%1.in carry.in &gt;nul
echo Problem Test
echo Data %1
time&lt;enter
carry.exe
time&lt;enter
fc carry.out carry%1.out
pause
goto end
:loop
echo.&gt;enter
for %%i in (1 2 3 4 5 6 7 8 9 10) do call %0 %%i
del enter
del carry.in
del carry.out
:end
</code></pre>
<p>其中 ：</p>
<ul>
<li>
<p><code>carry</code>  为题目文件名，可以修改。</p>
</li>
<li>
<p><code>for %%i in (1 2 3 4 5 6 7 8 9 10) do call %0 %%i</code> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 组测试数据，可以修改，如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 组： <code>for %%i in (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15) do call %0 %%i</code></p>
</li>
<li>
<p><code>fc carry.out carry%1.out</code> 的后一个 <code>.out</code> 可以修改，如 <code>.ans</code></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 排序笔记]]></title>
        <id>https://zxh23682.github.io/post/c-pai-xu-bi-ji/</id>
        <link href="https://zxh23682.github.io/post/c-pai-xu-bi-ji/">
        </link>
        <updated>2020-11-16T12:38:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="模板">模板：</h3>
<pre><code class="language-cpp">void selection_sort(int* a, int n) {
	for (int i = 1; i &lt; n; ++i) {
		int ith = i;
		for (int j = i + 1; j &lt;= n; ++j) {
			if (a[j] &lt; a[ith]) {
				ith = j;
			}
		}
		int t = a[i];
		a[i] = a[ith];
		a[ith] = t;
	}
} //xuan ze pai xu



void bubble_sort(int *a, int n) {
	bool flag = true;
	while (flag) {
		flag = false;
		for (int i = 1; i &lt; n; ++i) {
			if (a[i] &gt; a[i + 1]) {
				flag = true;
				int t = a[i];
				a[i] = a[i + 1];
				a[i + 1] = t;
			}
		}
	}
}//mao pao pai xu



void insertion_sort(int* a, int n) {
	for (int i = 2; i &lt;= n; ++i) {
		int key = a[i];
		int j = i - 1;
		while (j &gt; 0 &amp;&amp; a[j] &gt; key) {
			a[j + 1] = a[j];
			--j;
		}
		a[j + 1] = key;
	}
}//cha ru pai xu



const int N = 100010;
const int W = 100010;

int n, w, a[N], cnt[W], b[N];

void counting_sort() {
	memset(cnt, 0, sizeof(cnt));
	for (int i = 1; i &lt;= n; ++i) ++cnt[a[i]];
	for (int i = 1; i &lt;= w; ++i) cnt[i] += cnt[i - 1];
	for (int i = n; i &gt;= 1; --i) b[cnt[a[i]]--] = a[i];
} //计数排序



const int N = 100010;
const int W = 100010;
const int K = 100;

int n, w[K], k, cnt[W];

struct Element {
	int key[K];
	bool operator&lt;(const Element&amp; y) const {
		for (int i = 1; i &lt;= k; ++i) {
			if (key[i] == y.key[i]) continue;
			return key[i] &lt; y.key[i];
		}
		return false;
	}
} a[N], b[N];

void counting_sort(int p) {
	memset(cnt, 0, sizeof(cnt));
	for (int i = 1; i &lt;= n; ++i) ++cnt[a[i].key[p]];
	for (int i = 1; i &lt;= w[p]; ++i) cnt[i] += cnt[i - 1];
	for (int i = n; i &gt;= 1; --i) b[cnt[a[i].key[p]]--] = a[i];
	memcpy(a, b, sizeof(a));
}

const int N = 100010;
const int W = 100010;
const int K = 100;

int n, w[K], k, cnt[W];

struct Element {
	int key[K];
	bool operator&lt;(const Element&amp; y) const {
		for (int i = 1; i &lt;= k; ++i) {
			if (key[i] == y.key[i]) continue;
			return key[i] &lt; y.key[i];
		}
		return false;
	}
} a[N], b[N];

void counting_sort(int p) {
	memset(cnt, 0, sizeof(cnt));
	for (int i = 1; i &lt;= n; ++i) ++cnt[a[i].key[p]];
	for (int i = 1; i &lt;= w[p]; ++i) cnt[i] += cnt[i - 1];
	for (int i = n; i &gt;= 1; --i) b[cnt[a[i].key[p]]--] = a[i];
	memcpy(a, b, sizeof(a));
}

void radix_sort() {
	for (int i = k; i &gt;= 1; --i) {
		counting_sort(i);
	}
} //基数排序



struct Range {
	int start, end;
	Range(int s = 0, int e = 0) {
		start = s, end = e;
	}
};

template &lt;typename T&gt;
void quick_sort(T arr[], const int len) {
	if (len &lt;= 0) return;
	Range r[len];
	int p = 0;
	r[p++] = Range(0, len - 1);
	while (p) {
		Range range = r[--p];
		if (range.start &gt;= range.end) continue;
		T mid = arr[range.end];
		int left = range.start, right = range.end - 1;
		while (left &lt; right) {
			while (arr[left] &lt; mid &amp;&amp; left &lt; right) left++;
			while (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--;
			std::swap(arr[left], arr[right]);
		}
		if (arr[left] &gt;= arr[range.end])
			std::swap(arr[left], arr[range.end]);
		else
			left++;
		r[p++] = Range(range.start, left - 1);
		r[p++] = Range(left + 1, range.end);
	}
} //kuai su pai xu




void merge(int ll, int rr) {
	// 用来把 a[ll.. rr - 1] 这一区间的数排序。 t 数组是临时存放有序的版本用的。
	if (rr - ll &lt;= 1) return;
	int mid = ll + (rr - ll &gt;&gt; 1);
	merge(ll, mid);
	merge(mid, rr);
	int p = ll, q = mid, s = ll;
	while (s &lt; rr) {
		if (p &gt;= mid || (q &lt; rr &amp;&amp; a[p] &gt; a[q])) {
			t[s++] = a[q++];
			// ans += mid - p;
		} else
			t[s++] = a[p++];
	}
	for (int i = ll; i &lt; rr; ++i) a[i] = t[i];
}//gui bing pai xu



void max_heapify(int arr[], int start, int end) {
	int dad = start;
	int son = dad * 2 + 1;
	while (son &lt;= end) {
		if (son + 1 &lt;= end &amp;&amp;
		        arr[son] &lt; arr[son + 1])
			son++;
		if (arr[dad] &gt;
		        arr[son])
			return;
		else {
			swap(arr[dad], arr[son]);
			dad = son;
			son = dad * 2 + 1;
		}
	}
}

void heap_sort(int arr[], int len) {
	for (int i = len / 2 - 1; i &gt;= 0; i--) max_heapify(arr, i, len - 1);
	for (int i = len - 1; i &gt; 0; i--) {
		swap(arr[0], arr[i]);
		max_heapify(arr, 0, i - 1);
	}
} //dui pai xu




const int N = 100010;

int n, w, a[N];
vector&lt;int&gt; bucket[N];

void insertion_sort(vector&lt;int&gt;&amp; A) {
	for (int i = 1; i &lt; A.size(); ++i) {
		int key = A[i];
		int j = i - 1;
		while (j &gt;= 0 &amp;&amp; A[j] &gt; key) {
			A[j + 1] = A[j];
			--j;
		}
		A[j + 1] = key;
	}
}

void bucket_sort() {
	int bucket_size = w / n + 1;
	for (int i = 0; i &lt; n; ++i) {
		bucket[i].clear();
	}
	for (int i = 1; i &lt;= n; ++i) {
		bucket[a[i] / bucket_size].push_back(a[i]);
	}
	int p = 0;
	for (int i = 0; i &lt; n; ++i) {
		insertion_sort(bucket[i]);
		for (int j = 0; j &lt; bucket[i].size(); ++j) {
			a[++p] = bucket[i][j];
		}
	}
}//tong pai xu



template &lt;typename T&gt;
void shell_sort(T array[], int length) {
	int h = 1;
	while (h &lt; length / 3) {
		h = 3 * h + 1;
	}
	while (h &gt;= 1) {
		for (int i = h; i &lt; length; i++) {
			for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) {
				std::swap(array[j], array[j - h]);
			}
		}
		h = h / 3;
	}
}//xi er pai xu


int n, a[maxn], tmp[maxn &lt;&lt; 1];

int winner(int pos1, int pos2) {
	int u = pos1 &gt;= n ? pos1 : tmp[pos1];
	int v = pos2 &gt;= n ? pos2 : tmp[pos2];
	if (tmp[u] &lt;= tmp[v]) return u;
	return v;
}

void creat_tree(int &amp;value) {
	for (int i = 0; i &lt; n; i++) tmp[n + i] = a[i];
	for (int i = 2 * n - 1; i &gt; 1; i -= 2) {
		int k = i / 2;
		int j = i - 1;
		tmp[k] = winner(i, j);
	}
	value = tmp[tmp[1]];
	tmp[tmp[1]] = INF;
}

void recreat(int &amp;value) {
	int i = tmp[1];
	while (i &gt; 1) {
		int j, k = i / 2;
		if (i % 2 == 0 &amp;&amp; i &lt; 2 * n - 1)
			j = i + 1;
		else
			j = i - 1;
		tmp[k] = winner(i, j);
		i = k;
	}
	value = tmp[tmp[1]];
	tmp[tmp[1]] = INF;
}

void tournament_sort() {
	int value;
	creat_tree(value);
	for (int i = 0; i &lt; n; i++) {
		a[i] = value;
		recreat(value);
	}
}//jing biao sai pai xu
</code></pre>
<h3 id="完整代码">完整代码</h3>
<p>快速排序：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e4+5;
int n;
int a[maxn];
void qsort(int l,int r) {
	int m,n;
	int mid,p;
	m=l,n=r;
	mid=a[(l+r)/2];           
	do {
		while (a[m]&lt;mid) m++;  
		while (a[n]&gt;mid) n--;    
		if (m&lt;=n) {
			swap(a[m],a[n]);
			m++; 
			n--;           
		}
	} while (m&lt;=n);             
	if (m&lt;n) qsort(l,n);            
	if (m&lt;r) qsort(m,r);
}
int main() {
	freopen(&quot;kp.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;kp.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]);
	qsort(1,n);
	for (int i=1; i&lt;=n; i++) printf(&quot;%d &quot;,a[i]);	
	fclose(stdin);
	fclose(stdout);
	return 0;
}
</code></pre>
<h3 id="时间复杂度">时间复杂度</h3>
<figure data-type="image" tabindex="1"><img src="https://ericnth.cn/wp-content/uploads/2020/08/849589-20180402133438219-1946132192-1536x1038.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P6784 「EZEC-3」造房子]]></title>
        <id>https://zxh23682.github.io/post/ti-jie-p6784-ezec-3-zao-fang-zi/</id>
        <link href="https://zxh23682.github.io/post/ti-jie-p6784-ezec-3-zao-fang-zi/">
        </link>
        <updated>2020-11-15T06:57:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意：</h3>
<p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 块钱、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 材料和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 材料，造第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 层楼需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 材料与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 材料，每块钱都可以用来买 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 材料或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 材料，问最多可以造几层楼。</p>
<hr>
<h3 id="思路">思路：</h3>
<p>要求最多可以造几层楼，那么只要暴力枚举第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 层即可。</p>
<p>注意数据范围，要开 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">ull</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span></p>
<hr>
<h3 id="code">Code:</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef unsigned long long ull;
ull a,b,c;
ull ans;
int main() {
	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; //输入 
	if(a&gt;b) swap(a,b); //如果 a&gt;b 就交换 a,b 的值 
	for (ans=1;;ans++) { //无条件循环枚举每一层 
		if(a&lt;ans) { //如果 a&lt;ans 
			if(a+c &gt;= ans) {
				c-=ans-a;
				a=ans;
			}
			else break;
		}
		if(b&lt;ans) { //如果 b&lt;ans 
			if(b+c &gt;= ans) {
				c-=ans-b;
			    b = ans;
			}
			else break;
		}
		a-=ans, b-=ans;
	}
	cout&lt;&lt;ans-1; //注意输出的是 ans-1 
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【置顶】我的个人信息]]></title>
        <id>https://zxh23682.github.io/post/wo-de-ge-ren-xin-xi/</id>
        <link href="https://zxh23682.github.io/post/wo-de-ge-ren-xin-xi/">
        </link>
        <updated>2020-11-15T03:20:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="我的个人信息">我的个人信息：</h2>
<p>我的名字首字母：<code>zxh</code></p>
<p>我的学校：上海市民办华育中学。</p>
<p>我的邮箱：<code>hy23682@126.com</code></p>
<p>我的洛谷账号：<a href="https://www.luogu.com.cn/user/351320">zxh23682</a></p>
<p>我的<code>github</code>：<a href="https://github.com/zxh23682/">zxh23682</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF878B 【Teams Formation】]]></title>
        <id>https://zxh23682.github.io/post/ti-jie-cf878b-teams-formation/</id>
        <link href="https://zxh23682.github.io/post/ti-jie-cf878b-teams-formation/">
        </link>
        <updated>2020-11-15T03:03:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意：</h3>
<p>给出一个长为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的序列，将其重复 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 次，连续相等的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的个元素可以被消除，问最后剩余多少个元素。</p>
<h3 id="思路">思路：</h3>
<p>首先我们先考虑单个串，如果单个串中有恰好 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的倍数个连续相同字符，那么我们应该先将其消除，那么第一步我们遍历数组，这里我们需要用到一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>i</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">pair</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 数组,数组中前面存数值，后面存个数。</p>
<p>这样如果我们遍历到的数字和前一个相同也就是找到了连续相同的，我们只需要给顶部的元素的 <code>st[top].second+1</code>，如果发现和前一个元素不同说明已经不连续相同了，这时候我们再把这个数放进去，这样的好处就是我们 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>i</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">pair</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 数组中用一个数字和其个数代表了连续相等的串，这样我们只需要判断 <code>st[i].second%k</code> 是否等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 就可以。</p>
<p>这样对于初始串的处理就结束了，我们就得到的消去连续的后的单个串的个数我们记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">rec</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span></span></span></span>。</p>
<p>然后我们观察，发现对于每两个串相连，其实就是一个串的首尾相连把连续相同的k个消去，这样我们还是对一个串处理，我们继续处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>i</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">pair</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 数组。</p>
<p>用两个下标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 从两边向中间缩，如果两头数字相同并且，他们的个数之和恰好是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的倍数，那么这一堆全都可以消去，这样我们让 <code>l++，r++</code>，记录下消除的个数，一直到两头数字不能完全消除为止。</p>
<p>用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">while</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> 循环实现，每个串消除的首尾总个数记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>c</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">rec2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord">2</span></span></span></span>，同时我们发现第一个串的首和最后一个串尾可能不会接触，那么我们可以确定一定会减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>c</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">rec2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord">2</span></span></span></span>。</p>
<p>接下来分两种情况讨论即可：</p>
<ul>
<li>
<p>只剩下了一种数字</p>
</li>
<li>
<p>剩下多种数字</p>
</li>
</ul>
<p>注意要开 <code>long long</code>。</p>
<h3 id="code">Code:</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
ll a[100005];
pair&lt;ll,ll&gt; st[100005];
ll top,n,m,k,l,r,rec,rec2;
ll ans;
int main() {
	scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;k,&amp;m);
	for(ll i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]);
	for(ll i=1; i&lt;=n; i++) {
		if(!top || st[top].first!=a[i]) st[++top]=make_pair(a[i],1);
		else st[top].second=(st[top].second + 1)%k;
		if(st[top].second==0) top--;
	}
	for(ll i=1; i&lt;=top; i++) rec += st[i].second;
	l=1,r=top;
	while(l&lt;r &amp;&amp; st[l].first==st[r].first &amp;&amp; (st[l].second+st[r].second)%k==0) {
		rec2 += st[l].second+st[r].second;
		l++;
		r--;
	}
	if(l==r) {
		if(st[l].second*m%k==0) ans -= rec2;
		ans += m*rec-rec2*(m-1)-(st[l].second*m/k*k);
	} else {
		if(st[l].first==st[r].first) rec2 += (st[l].second+st[r].second)/k*k;
		ans=m*rec-rec2*(m - 1);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P6833 【[Cnoi2020]雷雨】]]></title>
        <id>https://zxh23682.github.io/post/ti-jie-p6833-cnoi2020lei-yu/</id>
        <link href="https://zxh23682.github.io/post/ti-jie-p6833-cnoi2020lei-yu/">
        </link>
        <updated>2020-11-15T02:56:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="思路">思路</h3>
<p>可以想到，这题其实就是找一个点满足这个点到题目要求的三个点的最短路之和最小（去除重复部分），所以直接用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span><br>
求出三个点到每个点的最短路，然后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 扫描每个点找出满足上述条件的点即可。</p>
<p>注意：输入的矩阵第一行是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 然后递减，所以如果是从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 开始输入的需要把题目中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 替换。</p>
<p><strong>此题需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">long</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">long</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 。</strong></p>
<hr>
<h3 id="code">Code:</h3>
<pre><code class="language-cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int A = 1e3 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
bool vis[A][A];
int n, m, a, b, c;
ll dis[3][A][A], mapp[A][A];

struct node {
	int x, y;
	ll val;
	bool operator &lt; (const node &amp;b) const {
		return val &gt; b.val;
	}
};


inline void Dij(int sx, int sy, int tag) {
	priority_queue &lt;node&gt; Q;
	memset(dis[tag], inf, sizeof(dis[tag]));
	memset(vis, 0, sizeof(vis));
	dis[tag][sx][sy] = mapp[sx][sy];
	Q.push((node) {
		sx, sy, dis[tag][sx][sy]
	});
	while (!Q.empty()) {
		int x = Q.top().x, y = Q.top().y;
		Q.pop();
		if (vis[x][y]) continue;
		vis[x][y] = 1;
		for (int i=0; i&lt;4; i++) {
			int bx = x + dx[i], by = y + dy[i];
			if (bx &gt; n || bx &lt; 1 || by &gt; m || by &lt; 1) continue;
			if (dis[tag][bx][by] &gt; dis[tag][x][y] + mapp[bx][by]) {
				dis[tag][bx][by] = dis[tag][x][y] + 1ll * mapp[bx][by];
				Q.push((node) {
					bx, by, dis[tag][bx][by]
				});
			}
		}
	}
}

int main() {
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b&gt;&gt;c;
	for (int i=1; i&lt;=n; i++) for (int j=1; j&lt;=m; j++) cin&gt;&gt;mapp[i][j];
	Dij(1, a, 0);
	Dij(n, b, 1);
	Dij(n, c, 2);
	ll ans = 1e18;
	for (int i=1; i&lt;=n; i++) {
		for (int j=1; j&lt;=m; j++) {
			ans = min(ans, dis[0][i][j] + dis[1][i][j] + dis[2][i][j] - 2 * mapp[i][j]);
		}
	}
	cout&lt;&lt;ans;
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P6855 【「EZEC-4.5」走方格】]]></title>
        <id>https://zxh23682.github.io/post/ti-jie-p6855-ezec-45-zou-fang-ge/</id>
        <link href="https://zxh23682.github.io/post/ti-jie-p6855-ezec-45-zou-fang-ge/">
        </link>
        <updated>2020-11-15T02:50:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意：</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∗</mi></mrow><annotation encoding="application/x-tex">∗</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的网格，每个格子有一个数，可以选择一个位置变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。要求最小化最大权值和路径。</p>
<h3 id="思路">思路：</h3>
<p>考虑枚举哪个位置变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，一个位置变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 后我们将路径分为两种路径，一种是经过该点的路径，一种是不经过该点的路径。</p>
<p>我们预处理出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的最大权和， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(n,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 的最大权和。然后我们发现如果不走 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 这个位置，那么一会走 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>−</mo><mo>&gt;</mo><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,y)-&gt;(i,y+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">i&lt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>；或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>−</mo><mo>&gt;</mo><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,j)-&gt;(x+1,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">j&lt;y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 计算这些走法的最大权值和即可。</p>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p>
<hr>
<h3 id="code">Code：</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
ll n,m,a[2005][2005],f[2005][2005],g[2005][2005],ar[2005][2005],br[2005][2005];
int main() {
	cin&gt;&gt;n&gt;&gt;m;
	for(ll i=1; i&lt;=n; i++)
		for(ll j=1; j&lt;=m; j++) {
			cin&gt;&gt;a[i][j];
			f[i][j] = max(f[i-1][j],f[i][j-1])+a[i][j];
		}
	for(ll i=n; i&gt;=1; i--)
		for(ll j=m; j&gt;=1; j--) {
			g[i][j] = max(g[i+1][j],g[i][j+1])+a[i][j];
			ar[i][j] = f[i][j]+g[i+1][j];
			br[i][j] = f[i][j]+g[i][j+1];
		}
	ll ans=1e18;
	for(ll i=1; i&lt;=n; i++)
		for(ll j=1; j&lt;=m; j++) {
			ll z = max(f[i][j]+g[i][j]-2*a[i][j],max(ar[i][j-1],br[i-1][j]));
			ans = min(ans,z);
			if(j!=1) ar[i][j] = max(ar[i][j],ar[i][j-1]);
			if(i!=1) br[i][j] = max(br[i][j],br[i-1][j]);
		}
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P7071 【优秀的拆分】]]></title>
        <id>https://zxh23682.github.io/post/ti-jie-p7071-you-xiu-de-chai-fen/</id>
        <link href="https://zxh23682.github.io/post/ti-jie-p7071-you-xiu-de-chai-fen/">
        </link>
        <updated>2020-11-15T02:49:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="思路">思路：</h3>
<p>首先，易得如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 为奇数就输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p>
<p>由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>23</mn></msup><mo>&lt;</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">2^{23}&lt;10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>&gt;</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">2^{24}&gt;10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>，所以从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>24</mn></mrow><annotation encoding="application/x-tex">24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 枚举，找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 次方小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 就输出，把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 减去上一个符合的数，直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 就跳出循环。</p>
<hr>
<h3 id="code">Code：</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
ll n;
int main() {
//	freopen(&quot;power.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;power.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%lld&quot;,&amp;n);
	if (n%2==1) { //如果n为奇数就 输出-1
		printf(&quot;-1\n&quot;);
		fclose(stdin);
		fclose(stdout);
		return 0;
	}
	for (int i=24;i&gt;=1;i--) {
		if (pow(2,i)&lt;=n) {
			cout&lt;&lt;(ll)pow(2,i)&lt;&lt;&quot; &quot;; //找到符合的就输出，注意要用long long输出
			n -= pow(2,i); //减去上一个输出的数
		}
		if (n==0) break; //n为0时就结束程序
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P1444 【[USACO1.3]虫洞 wormhole】]]></title>
        <id>https://zxh23682.github.io/post/ti-jie-p1444-usaco13chong-dong-wormhole/</id>
        <link href="https://zxh23682.github.io/post/ti-jie-p1444-usaco13chong-dong-wormhole/">
        </link>
        <updated>2020-11-15T02:49:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意：</h3>
<p>给定一些点，在横向穿过这些点时将会被传送回纵坐标相同的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 轴上，问有多少种情况会使得永远向右爬的虫子陷入死循环。</p>
<h3 id="思路">思路：</h3>
<p>首先因为只会向右爬，所以我们只需将同一行上的点间连边，然后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span> 暴力找匹配，之后判环即可。</p>
<h3 id="code">Code：</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define x second
#define y first
using namespace std;
int n,to[20],pre[20],ans;
bool vis[20];
pair&lt;int,int&gt;p[20];
bool check(int k) { //判环
	while(to[k]) {
		if(vis[k]) return true;
		vis[k]=true;
		k=pre[to[k]];
	}
	return false;
}
void dfs(int dep) { //暴力找匹配
	if(dep&gt;n) {
		for(int i=1; i&lt;=n; i++) {
			fill(vis+1,vis+1+n,0);
			if(check(i)) {
				ans++;
				return;
			}
		}
		return;
	}
	if(pre[dep]) dfs(dep+1);
	else {
		for(int i=dep+1; i&lt;=n; i++)
			if(!pre[i]) {
				pre[i]=dep;
				pre[dep]=i;
				dfs(dep+1);
				pre[i]=0;
				pre[dep]=0;
			}
	}
}
int main() {
	cin&gt;&gt;n;
	for(int i=1; i&lt;=n; i++) cin&gt;&gt;p[i].x&gt;&gt;p[i].y;
	sort(p+1,p+1+n);
	for(int i=1; i&lt;n; i++) if(p[i].y==p[i+1].y) to[i]=i+1;
	dfs(1);
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P6123 【[Neerc2016]Hard Refactoring】]]></title>
        <id>https://zxh23682.github.io/post/ti-jie-p6123-neerc2016hard-refactoring/</id>
        <link href="https://zxh23682.github.io/post/ti-jie-p6123-neerc2016hard-refactoring/">
        </link>
        <updated>2020-11-15T02:48:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="思路">思路：</h3>
<p>简单模拟，数字区间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msup><mn>2</mn><mn>15</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>15</mn></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">[2^{15},2^{15}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，全取为 <code>true</code> ，全不取为 <code>false</code> 。否则按最简表达式给出范围。</p>
<p>对于输入给的表达式，读取其表示的区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> ，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>&lt;</mo><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l &lt;= r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> ，则将其在一维数轴上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 每个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span> 。</p>
<p>对结果判断，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msup><mn>2</mn><mn>15</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>15</mn></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">[2^{15},2^{15}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span><br>
区间的每个数字判断其是否能够取到，并合并区间，打印若干段不连续区间即可。</p>
<p>对于如何快速对区间修改及单点查询，通过树状数组即可。</p>
<p>注意处理好输入输出格式问题。</p>
<hr>
<h3 id="code">Code：</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int BASE = 32769;
const int N = 70005;
int bin[N];
inline int lowbit(int x) {
	return x &amp; -x;
}
void add(int x, int w) {
	for(int i=x; i&lt;N; i+=lowbit(i)) bin[i] += w;
}
int sum(int x) {
	int ret = 0;
	for(int i=x; i; i-=lowbit(i)) ret += bin[i];
	return ret;
}
void update(int x, int y, int w) {
	add(x, w),add(y+1, -w);
}
int main() {

	char x[2], op[5], eop0, eop1;
	int lmt, lft, rgt;
	while(true) {
		lft = -32768,rgt = 32767;
		scanf(&quot; %s %s %d&quot;, x, op, &amp;lmt);
		if(op[0] == '&lt;') rgt = lmt;
		else lft = lmt;
		if(cin&gt;&gt;eop0&gt;&gt;eop1) {
			if(eop0 == '&amp;') {
				scanf(&quot; %c %s %d&quot;, &amp;x, op, &amp;lmt);
				if(op[0] == '&lt;') rgt = min(lmt, rgt);
				else lft = max(lft, lmt);
			}
			if(lft &lt;= rgt) update(lft + BASE, rgt + BASE, 1);
			if(eop0 == '&amp;') {
				if(cin&gt;&gt;eop0&gt;&gt;eop1);
				else break;
			}
		} else {
			if(lft &lt;= rgt) update(lft + BASE, rgt + BASE, 1);
			break;
		}
	}
	int cnt = 0;
	lft = -BASE;
	bool flg = false;
	for(int i=1, val; i&lt;=BASE + 32767; i++) {
		val = sum(i);
		cnt += (val &gt; 0 ? 1 : 0);
		if(lft == -BASE &amp;&amp; val) lft = i-BASE;
		if(lft != -BASE &amp;&amp; val == 0) {
			if(flg) printf(&quot; ||\n&quot;);
			if(lft == 1-BASE) printf(&quot;x &lt;= %d&quot;, i-BASE-1);
			else printf(&quot;x &gt;= %d &amp;&amp; x &lt;= %d&quot;, lft, i-BASE-1);
			lft = -BASE;
			flg = true;
		}
	}
	if(cnt == 0) printf(&quot;false\n&quot;);
	else if(cnt == 32768*2) printf(&quot;true\n&quot;);
	else if(lft != -BASE) {
		if(flg) printf(&quot; ||\n&quot;);
		printf(&quot;x &gt;= %d&quot;, lft);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>