<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zxh23682.github.io</id>
    <title>zxh23682 的博客</title>
    <updated>2020-11-25T13:00:24.750Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zxh23682.github.io"/>
    <link rel="self" href="https://zxh23682.github.io/atom.xml"/>
    <subtitle>一个蒟蒻OIer</subtitle>
    <logo>https://zxh23682.github.io/images/avatar.png</logo>
    <icon>https://zxh23682.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, zxh23682 的博客</rights>
    <entry>
        <title type="html"><![CDATA[C++ 对拍]]></title>
        <id>https://zxh23682.github.io/post/c-dui-pai/</id>
        <link href="https://zxh23682.github.io/post/c-dui-pai/">
        </link>
        <updated>2020-11-25T12:54:48.000Z</updated>
        <content type="html"><![CDATA[<p>共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>p</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">cpp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span></span></span></span> 文件<br>
各个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>p</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">cpp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span></span></span></span> 文件的含义：</p>
<ul>
<li><code>1.cpp</code>是自己的程序</li>
<li><code>2.cpp</code>是正确答案</li>
<li><code>3.cpp</code>是随机数程序，在本程序中，生成的输入内容不需要指定输出到哪个文件，只需要直接输出。</li>
<li><code>4.cpp</code>是对拍程序。</li>
</ul>
<p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>p</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">cpp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span></span></span></span> 文件运行后，把 <code>1.exe</code>，<code>2.exe</code>，<code>3.exe</code>，<code>4,cpp</code> 放到同一目录下，再运行 <code>4.cpp</code>。</p>
<p>对拍程序（即 <code>4.cpp</code>）代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;ctime&gt;
int main()
{
    long s,t;
    while(1)
    {
        system(&quot;cls&quot;);
        do{
            system(&quot;3 &gt; 3.in&quot;);  //数据生成程序
            s=clock();
            system(&quot;1 &lt; 3.in &gt; 1.out&quot;);  //自己程序
            t=clock();
            system(&quot;2 &lt; 3.in &gt; 2.out&quot;);  //答案
            if(system(&quot;fc 1.out  2.out &gt; nul&quot;))break;
            else printf(&quot;AC time: %ldms\n&quot;,t-s);
        }while(1);
        printf(&quot;WA time: %ldms\n&quot;,t-s);
        system(&quot;fc 1.out 2.out&quot;);
        system(&quot;pause &gt; nul&quot;);
    }
}
</code></pre>
<p>如果正确，就会显示 <code>FC：找不到差异</code>。</p>
<p>程序停止后，可以打开 <code>3.in</code> 查看输入，<code>1.out</code> 和 <code>2.out</code> 查看输出。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安装 NOI Linux 操作系统]]></title>
        <id>https://zxh23682.github.io/post/an-zhuang-noi-linux-cao-zuo-xi-tong/</id>
        <link href="https://zxh23682.github.io/post/an-zhuang-noi-linux-cao-zuo-xi-tong/">
        </link>
        <updated>2020-11-19T12:06:35.000Z</updated>
        <content type="html"><![CDATA[<!-- wp:heading -->
<h2>准备工作</h2>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>NOI Linux 1.4.1 iso镜像<a href="https://sys-code.oss-cn-beijing.aliyuncs.com/NOI/noilinux-1.4.1.iso">（点我下载）</a>
<!-- /wp:paragraph -->
<!-- wp:heading -->
<h2>我们开始吧！</h2>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>打开VMware Workstation 15.x（更低版本也没什么问题，像VirtualBox这些其它虚拟机软件也行），在“库”一栏中右键，选择“新建虚拟机”。<br><img src="https://img-blog.csdnimg.cn/20200225162318852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>在向导里选典型，继续。<br><img src="https://img-blog.csdnimg.cn/2020022516252028.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>选择“稍后安装操作系统”，下一步。<br>（用过的都知道那个简易安装有多恶心，非VMware没有此问题）</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>选择Linux，版本是Ubuntu（如果是64位电脑可以选择Ubuntu 64位，电脑是几位的可以通过右键“计算机”-&gt;属性-&gt;系统-&gt;系统类型查看），下一步。<br><img src="https://img-blog.csdnimg.cn/20200225162833276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>取个自己喜欢的名字，不要有中文，最好不要有空格，下一步。<br>（提示：最好不要放在系统盘（C:）否则更慢！）<br><img src="https://img-blog.csdnimg.cn/20200225163122949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>20GB足够，（这是上限，可以开高点。安装大概只要2个G左右）。单个文件性能好，选他。<img src="https://img-blog.csdnimg.cn/20200225163425591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>注意，刹住！跟着图片走！<br>使用iso镜像文件，载入你刚刚千辛万苦下载的noilinux-1.4.1.iso，并点“关闭”，“完成”。（可以再选择显示器&gt;加速3D图形）</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><img src="https://img-blog.csdnimg.cn/20200225163621887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>好了，虚拟机创建好了！<br>（——不过，这只是完成了一个小目标…）<br>——————————————————————————</p>
<!-- /wp:paragraph -->
<!-- wp:heading -->
<h2>安装NOI Linux</h2>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>开启此虚拟机。<br>等它跳来跳去，等个半分钟左右，出现下下图，就可以开始安装了。<br><img src="https://img-blog.csdnimg.cn/20200225164222697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200225164409536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>选择中文（简体），安装Ubuntu。<br><img src="https://img-blog.csdnimg.cn/20200225164608128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>继续，两个复选框统统不要。<br><img src="https://img-blog.csdnimg.cn/20200225164710463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>清除整个磁盘并安装。<br><img src="https://img-blog.csdnimg.cn/20200225164853992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>我在哪里？如实告诉他就行了，反正它也找不到我。<br><img src="https://img-blog.csdnimg.cn/20200225165116440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>汉语，汉语，继续。<br><img src="https://img-blog.csdnimg.cn/20200225165201223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>慢慢等待吧。</p>
<!-- /wp:paragraph -->
如果断了网，大概15分钟就装好了。</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><br><img src="https://img-blog.csdnimg.cn/20200225165223132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>装完后他会提示你要重启，你确定。【注意！如果重启了2，3分钟没动静，果断拔电！（强制关机），这是你重新打开它应该已经装好可以用了。】</p></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>这里就不等了，直接给大家看成品吧！默认用户名noilinux，密码123456，墙纸是我另外设的.<br><img src="https://img-blog.csdnimg.cn/20200225170003333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>第一次我装的时候简直苦恼的不行，因为分辨率实在太低【相信大家现在也这样吧】，连设置都无法设定（分辨率太低让“完成”按钮愣是点不到，糟心~），这里给大家一个方法。</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Ctrl+Alt+T运行终端，输入sudo gedit /etc/default/grub（sudo类似于获取管理员权限，不然无法保存），按下Enter，以越快越好的速度输入密码（123456），大概两三秒后就要重试了。<img src="https://img-blog.csdnimg.cn/20200225170822105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>在打开的文件中加上这两行，如图（1280x800只是个人随便设的，你可以随便改（但一定要是标准的，如1920x1080,1366x768），注意是x不是*，应该原本设的是800x600，怪不得！），然后保存，重启。<br>GRUB_GFXMODE=1280x800<br>GRUB_GFXPAYLOAD_LINUX=keep<br><img src="https://img-blog.csdnimg.cn/20200225170946121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>好了！成功！<br>应该也有朋友注意到了，这里没装Ubuntu Software Center！<br>好了，这里给大家安装方法（我可搜了好久呢）<br>sudo apt install software-center<br>这个几分钟就行了，会有文字提示，比较好。</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>通过应用程序 编程-&gt;GUIDE来启动这个操作系统的主要目的——写程序。<br><img src="https://img-blog.csdnimg.cn/20200225171749870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200225171957210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>这些就不用说了吧。再讲一句，要保存为cpp文件才有语法高亮！！！<br><img src="https://img-blog.csdnimg.cn/20200225172059461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>通过键盘图标-&gt;输入法-&gt;GOOGLE拼音来打中文。<br><img src="https://img-blog.csdnimg.cn/20200225172221757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>好了，今天就写这么多啦，感兴趣的同志们可以去多学学Linux终端和命令行，那个比cmd强大多了！</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Linux安装便捷，使用稳定，不用担心蓝屏（Windows特产），等等，值得推荐！</p>
<!-- /wp:paragraph -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安装 Windows7 操作系统]]></title>
        <id>https://zxh23682.github.io/post/an-zhuang-windows7-cao-zuo-xi-tong/</id>
        <link href="https://zxh23682.github.io/post/an-zhuang-windows7-cao-zuo-xi-tong/">
        </link>
        <updated>2020-11-18T12:18:02.000Z</updated>
        <content type="html"><![CDATA[<!-- wp:paragraph -->
<p>Win7旗舰版-简体中文版镜像可以点<a href="http://d2.w10a.com/win7/cn_windows_7_ultimate_with_sp1_x64_dvd_677408.iso">这里</a>下载。当然用自己的也没问题的啦！<br>建议使用迅雷下载，亲测快很多。</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>好了，接下来我们开始安装。</p>
<!-- /wp:paragraph -->
<!-- wp:heading -->
<h2>以下内容仅虚拟机需要，物理机可直接跳至第9步！</h2>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>1.在“库”一栏中右键，选择“新建虚拟机”，使用“典型”设置。<br><img src="https://img-blog.csdnimg.cn/20200301133239539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt="在“库”一栏中右键，选择“新建虚拟机”"><br><img src="https://img-blog.csdnimg.cn/2020030113331520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt="使用“典型”设置。"><br>2.选择稍后创建操作系统。</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>3.操作系统选择Microsoft Windows，版本选择Windows 7，64位电脑的小伙伴们可以选择x64的，看电脑位数请参见这篇<a href="https://blog.csdn.net/EricNTH/article/details/104499438">博客</a>。<br><img src="https://img-blog.csdnimg.cn/20200301133748351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt="Windows7"><br>4.之后自己起一个喜欢的名字，最好不要有中文和空格哦！<br>5. 选择大小，装系统大概只要7.8个G就够了我设了40个G，大家可以设更多，反正只是上限。当然也可以设少一点，等会我们做双硬盘。单个文件性能好，选他。<br><img src="https://img-blog.csdnimg.cn/20200301134850743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>6. 停！选择“自定义硬件”，然后跟着图片操作，载入刚下载的iso映像。<img src="https://img-blog.csdnimg.cn/20200301135049140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>7. 声卡，打印机这些，如果不用，可以删除。如果想要更流畅，可以调高内存。<br>8. 网络NAT，桥接都可以。然后我们选择“添加…”，硬盘，再添加一个硬盘（可省略，如果要装双系统会方便一些。如果没有的话，可以先创建，然后在编辑设置里添加）。
<!-- /wp:paragraph -->
<!-- wp:separator -->
<hr class="wp-block-separator"/>
<!-- /wp:separator -->
<!-- wp:list {"ordered":true,"start":9} -->
<ol start="9"><li>好了，启动虚拟机。如图。<img src="https://img-blog.csdnimg.cn/20200301140021420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>10.选择语言，键盘，下一步。<img src="https://img-blog.csdnimg.cn/20200301140057986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>11.选择：现在安装。<img src="https://img-blog.csdnimg.cn/20200301140233495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p>显示“正在启动”。。。<img src="https://img-blog.csdnimg.cn/20200301140303645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>我接受，然后下一步<img src="https://img-blog.csdnimg.cn/20200301140417415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>选择“自定义”，否则很慢。<br><img src="https://img-blog.csdnimg.cn/20200301140537584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>装在哪里都可以，如果要装双系统建议不要装在磁盘0。否则建议选择磁盘0.<br><img src="https://img-blog.csdnimg.cn/20200301140556863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>12.开始安装了，可以泡个茶，大概十分钟就好了，期间可能会重启数次。展开比较慢，其它就比较快了。<br><img src="https://img-blog.csdnimg.cn/20200301140746625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>如图，正在重启。<br><img src="https://img-blog.csdnimg.cn/20200301140926839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>很快就好了！<br><img src="https://img-blog.csdnimg.cn/20200301141015827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>13.装完了，开始设置。输入自己的昵称。<br><img src="https://img-blog.csdnimg.cn/20200301141240434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>14.我们不用设置密码，直接下一步即可。<br><img src="https://img-blog.csdnimg.cn/20200301141322562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>输入激活密钥，网上一抓一大把，这里列一些在<a href="http://www.win7zhijia.cn/jiaocheng/win7_24688.html">Win7之家</a>找到的密钥。</p>
<!-- /wp:paragraph -->
<p><code>FJGCP-4DFJD-GJY49-VJBQ7-HYRR2</code></p>
<p><code>VQ3PY-VRX6D-CBG4J-8C6R2-TCVBD</code></p>
<p><code>2Y4WT-DHTBF-Q6MMK-KYK6X-VKM6G</code></p>
<p><code>342DG-6YJR8-X92GV-V7DCV-P4K27</code></p>
<p><code>9CW99-79BBF-D4M3X-9BK9M-4RPH9</code></p>
<p><code>MHFPT-8C8M2-V9488-FGM44-2C9T3</code></p>
<p><code>6K2KY-BFH24-PJW6W-9GK29-TMPWP</code></p>
<p><code>49PB6-6BJ6Y-KHGCQ-7DDY6-TF7CD</code></p>
<p><code>YJJYR-666KV-8T4YH-KM9TB-4PY2W</code></p>
<p><code>76MTG-QMQJQ-46DQR-CHRBB-7K3HD</code></p>
<p><code>4BRY2-6W9VH-9CM6R-GPKRY-HHVCY</code></p>
<p><code>2XQ63-J3P67-9G3JC-FHQ68-8Q2F3</code></p>
<p><code>KH2J9-PC326-T44D4-39H6V-TVPBY</code></p>
<p><code>87VT2-FY2XW-F7K39-W3T8R-XMFGF</code></p>
<p><code>236TW-X778T-8MV9F-937GT-QVKBB</code></p>
<p><code>RHTBY-VWY6D-QJRJ9-JGQ3X-Q2289</code></p>
<p><code>6K2KY-BFH24-PJW6W-9GK29-TMPWP</code></p>
<p><code>TFP9Y-VCY3P-VVH3T-8XXCC-MF4YK</code></p>
<p><code>RHTBY-VWY6D-QJRJ9-JGQ3X-Q2289</code></p>
<p><code>V77DJ-CT8WB-Y3GXT-X3FBP-6F987</code></p>
<p><code>PRG2C-6MTQ2-RPFKB-QFJRR-CDM36</code></p>
<p><br><img src="https://img-blog.csdnimg.cn/20200301141553638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>15.安全，选择“稍后询问我”。<br><img src="https://img-blog.csdnimg.cn/20200301141840499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>16.设置时间，北京时间UTC+8即可。<br><img src="https://img-blog.csdnimg.cn/20200301141918466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>17.根据自己的情况选择。<br><img src="https://img-blog.csdnimg.cn/20200301141955531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200301142039360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>18.OK！成功！ 安装完成！<br><img src="https://img-blog.csdnimg.cn/20200301142052350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>19.哎呀呀！这怎么行！桌面上只有“回收站”！<br><img src="https://img-blog.csdnimg.cn/20200301142212271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>桌面上右键，选择“个性化”。<br><img src="https://img-blog.csdnimg.cn/20200301142533980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>选择“更改桌面图标”。<br><img src="https://img-blog.csdnimg.cn/20200301142657484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>选择自己想要的，确定。<br><img src="https://img-blog.csdnimg.cn/20200301142737967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>好了，完成！<br>至于分辨率，桌面背景这些，大家可以自行上网搜索查阅。<br>好了，使用物理机的小伙伴们，你们的任务到此为止，再见！</p></p>
<!-- /wp:paragraph -->
<!-- wp:separator -->
<hr class="wp-block-separator"/>
<!-- /wp:separator -->
<!-- wp:paragraph -->
<p>20.安装VMware Tools（或者用 Virtualbox的选安装增强功能）</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>有没有觉得分辨率低看着很不顺眼？有没有想互相拖放文件？我们来安装Tools.<br>先选择“我已完成安装”（没有也没事）。<br>如图所示，右键该虚拟机，选择“安装VMware Tools”<br><img src="https://img-blog.csdnimg.cn/20200301143232152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>然后进入“计算机”，双击启动DVD驱动器VMware Tools。<br><img src="https://img-blog.csdnimg.cn/20200301143443818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>选择“是”<br><img src="https://img-blog.csdnimg.cn/2020030114352853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200301143541907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200301143719599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>准备完成后，就可以开始安装了，选择下一步。<br><img src="https://img-blog.csdnimg.cn/20200301143749400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>选择“典型安装”。<br><img src="https://img-blog.csdnimg.cn/20200301143810888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>选择“安装".<br><img src="https://img-blog.csdnimg.cn/20200301143857942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>然后就开始安装了，等待即可。<br><img src="https://img-blog.csdnimg.cn/20200301143930810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>安装完成，下面的提示框淡出，我们点完成即可。<br><img src="https://img-blog.csdnimg.cn/20200301144010433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>根据提示重启。<br><img src="https://img-blog.csdnimg.cn/20200301144046370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>好了，分辨率变高了，真好！<br><img src="https://img-blog.csdnimg.cn/20200301144356252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>21.现在大家可以进行分区设置，网上也有很多教程，这里只给大家放几张图片，不赘述了。</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>右键开始菜单的“计算机”，选择管理。<br><img src="https://img-blog.csdnimg.cn/20200301144522740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>选择“磁盘管理”。<br><img src="https://img-blog.csdnimg.cn/20200301144609433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VyaWNOVEg=,size_16,color_FFFFFF,t_70" alt=""><br>然后大家就可以设置了，根据喜好即可。可以分盘，也可以修改盘符。大家自己上网搜索吧！</p>
<!-- /wp:paragraph -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 测评bat文件模板]]></title>
        <id>https://zxh23682.github.io/post/c-ce-ping-bat-wen-jian-mo-ban/</id>
        <link href="https://zxh23682.github.io/post/c-ce-ping-bat-wen-jian-mo-ban/">
        </link>
        <updated>2020-11-18T10:16:20.000Z</updated>
        <content type="html"><![CDATA[<pre><code>@echo off
title TestData - carry
if &quot;%1&quot;==&quot;&quot; goto loop
copy carry%1.in carry.in &gt;nul
echo Problem Test
echo Data %1
time&lt;enter
carry.exe
time&lt;enter
fc carry.out carry%1.out
pause
goto end
:loop
echo.&gt;enter
for %%i in (1 2 3 4 5 6 7 8 9 10) do call %0 %%i
del enter
del carry.in
del carry.out
:end
</code></pre>
<p>其中 ：</p>
<ul>
<li>
<p><code>carry</code>  为题目文件名，可以修改。</p>
</li>
<li>
<p><code>for %%i in (1 2 3 4 5 6 7 8 9 10) do call %0 %%i</code> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 组测试数据，可以修改，如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 组： <code>for %%i in (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15) do call %0 %%i</code></p>
</li>
<li>
<p><code>fc carry.out carry%1.out</code> 的后一个 <code>.out</code> 可以修改，如 <code>.ans</code></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 排序笔记]]></title>
        <id>https://zxh23682.github.io/post/c-pai-xu-bi-ji/</id>
        <link href="https://zxh23682.github.io/post/c-pai-xu-bi-ji/">
        </link>
        <updated>2020-11-16T12:38:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="模板">模板：</h3>
<pre><code class="language-cpp">void selection_sort(int* a, int n) {
	for (int i = 1; i &lt; n; ++i) {
		int ith = i;
		for (int j = i + 1; j &lt;= n; ++j) {
			if (a[j] &lt; a[ith]) {
				ith = j;
			}
		}
		int t = a[i];
		a[i] = a[ith];
		a[ith] = t;
	}
} //xuan ze pai xu



void bubble_sort(int *a, int n) {
	bool flag = true;
	while (flag) {
		flag = false;
		for (int i = 1; i &lt; n; ++i) {
			if (a[i] &gt; a[i + 1]) {
				flag = true;
				int t = a[i];
				a[i] = a[i + 1];
				a[i + 1] = t;
			}
		}
	}
}//mao pao pai xu



void insertion_sort(int* a, int n) {
	for (int i = 2; i &lt;= n; ++i) {
		int key = a[i];
		int j = i - 1;
		while (j &gt; 0 &amp;&amp; a[j] &gt; key) {
			a[j + 1] = a[j];
			--j;
		}
		a[j + 1] = key;
	}
}//cha ru pai xu



const int N = 100010;
const int W = 100010;

int n, w, a[N], cnt[W], b[N];

void counting_sort() {
	memset(cnt, 0, sizeof(cnt));
	for (int i = 1; i &lt;= n; ++i) ++cnt[a[i]];
	for (int i = 1; i &lt;= w; ++i) cnt[i] += cnt[i - 1];
	for (int i = n; i &gt;= 1; --i) b[cnt[a[i]]--] = a[i];
} //计数排序



const int N = 100010;
const int W = 100010;
const int K = 100;

int n, w[K], k, cnt[W];

struct Element {
	int key[K];
	bool operator&lt;(const Element&amp; y) const {
		for (int i = 1; i &lt;= k; ++i) {
			if (key[i] == y.key[i]) continue;
			return key[i] &lt; y.key[i];
		}
		return false;
	}
} a[N], b[N];

void counting_sort(int p) {
	memset(cnt, 0, sizeof(cnt));
	for (int i = 1; i &lt;= n; ++i) ++cnt[a[i].key[p]];
	for (int i = 1; i &lt;= w[p]; ++i) cnt[i] += cnt[i - 1];
	for (int i = n; i &gt;= 1; --i) b[cnt[a[i].key[p]]--] = a[i];
	memcpy(a, b, sizeof(a));
}

const int N = 100010;
const int W = 100010;
const int K = 100;

int n, w[K], k, cnt[W];

struct Element {
	int key[K];
	bool operator&lt;(const Element&amp; y) const {
		for (int i = 1; i &lt;= k; ++i) {
			if (key[i] == y.key[i]) continue;
			return key[i] &lt; y.key[i];
		}
		return false;
	}
} a[N], b[N];

void counting_sort(int p) {
	memset(cnt, 0, sizeof(cnt));
	for (int i = 1; i &lt;= n; ++i) ++cnt[a[i].key[p]];
	for (int i = 1; i &lt;= w[p]; ++i) cnt[i] += cnt[i - 1];
	for (int i = n; i &gt;= 1; --i) b[cnt[a[i].key[p]]--] = a[i];
	memcpy(a, b, sizeof(a));
}

void radix_sort() {
	for (int i = k; i &gt;= 1; --i) {
		counting_sort(i);
	}
} //基数排序



struct Range {
	int start, end;
	Range(int s = 0, int e = 0) {
		start = s, end = e;
	}
};

template &lt;typename T&gt;
void quick_sort(T arr[], const int len) {
	if (len &lt;= 0) return;
	Range r[len];
	int p = 0;
	r[p++] = Range(0, len - 1);
	while (p) {
		Range range = r[--p];
		if (range.start &gt;= range.end) continue;
		T mid = arr[range.end];
		int left = range.start, right = range.end - 1;
		while (left &lt; right) {
			while (arr[left] &lt; mid &amp;&amp; left &lt; right) left++;
			while (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--;
			std::swap(arr[left], arr[right]);
		}
		if (arr[left] &gt;= arr[range.end])
			std::swap(arr[left], arr[range.end]);
		else
			left++;
		r[p++] = Range(range.start, left - 1);
		r[p++] = Range(left + 1, range.end);
	}
} //kuai su pai xu




void merge(int ll, int rr) {
	// 用来把 a[ll.. rr - 1] 这一区间的数排序。 t 数组是临时存放有序的版本用的。
	if (rr - ll &lt;= 1) return;
	int mid = ll + (rr - ll &gt;&gt; 1);
	merge(ll, mid);
	merge(mid, rr);
	int p = ll, q = mid, s = ll;
	while (s &lt; rr) {
		if (p &gt;= mid || (q &lt; rr &amp;&amp; a[p] &gt; a[q])) {
			t[s++] = a[q++];
			// ans += mid - p;
		} else
			t[s++] = a[p++];
	}
	for (int i = ll; i &lt; rr; ++i) a[i] = t[i];
}//gui bing pai xu



void max_heapify(int arr[], int start, int end) {
	int dad = start;
	int son = dad * 2 + 1;
	while (son &lt;= end) {
		if (son + 1 &lt;= end &amp;&amp;
		        arr[son] &lt; arr[son + 1])
			son++;
		if (arr[dad] &gt;
		        arr[son])
			return;
		else {
			swap(arr[dad], arr[son]);
			dad = son;
			son = dad * 2 + 1;
		}
	}
}

void heap_sort(int arr[], int len) {
	for (int i = len / 2 - 1; i &gt;= 0; i--) max_heapify(arr, i, len - 1);
	for (int i = len - 1; i &gt; 0; i--) {
		swap(arr[0], arr[i]);
		max_heapify(arr, 0, i - 1);
	}
} //dui pai xu




const int N = 100010;

int n, w, a[N];
vector&lt;int&gt; bucket[N];

void insertion_sort(vector&lt;int&gt;&amp; A) {
	for (int i = 1; i &lt; A.size(); ++i) {
		int key = A[i];
		int j = i - 1;
		while (j &gt;= 0 &amp;&amp; A[j] &gt; key) {
			A[j + 1] = A[j];
			--j;
		}
		A[j + 1] = key;
	}
}

void bucket_sort() {
	int bucket_size = w / n + 1;
	for (int i = 0; i &lt; n; ++i) {
		bucket[i].clear();
	}
	for (int i = 1; i &lt;= n; ++i) {
		bucket[a[i] / bucket_size].push_back(a[i]);
	}
	int p = 0;
	for (int i = 0; i &lt; n; ++i) {
		insertion_sort(bucket[i]);
		for (int j = 0; j &lt; bucket[i].size(); ++j) {
			a[++p] = bucket[i][j];
		}
	}
}//tong pai xu



template &lt;typename T&gt;
void shell_sort(T array[], int length) {
	int h = 1;
	while (h &lt; length / 3) {
		h = 3 * h + 1;
	}
	while (h &gt;= 1) {
		for (int i = h; i &lt; length; i++) {
			for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) {
				std::swap(array[j], array[j - h]);
			}
		}
		h = h / 3;
	}
}//xi er pai xu


int n, a[maxn], tmp[maxn &lt;&lt; 1];

int winner(int pos1, int pos2) {
	int u = pos1 &gt;= n ? pos1 : tmp[pos1];
	int v = pos2 &gt;= n ? pos2 : tmp[pos2];
	if (tmp[u] &lt;= tmp[v]) return u;
	return v;
}

void creat_tree(int &amp;value) {
	for (int i = 0; i &lt; n; i++) tmp[n + i] = a[i];
	for (int i = 2 * n - 1; i &gt; 1; i -= 2) {
		int k = i / 2;
		int j = i - 1;
		tmp[k] = winner(i, j);
	}
	value = tmp[tmp[1]];
	tmp[tmp[1]] = INF;
}

void recreat(int &amp;value) {
	int i = tmp[1];
	while (i &gt; 1) {
		int j, k = i / 2;
		if (i % 2 == 0 &amp;&amp; i &lt; 2 * n - 1)
			j = i + 1;
		else
			j = i - 1;
		tmp[k] = winner(i, j);
		i = k;
	}
	value = tmp[tmp[1]];
	tmp[tmp[1]] = INF;
}

void tournament_sort() {
	int value;
	creat_tree(value);
	for (int i = 0; i &lt; n; i++) {
		a[i] = value;
		recreat(value);
	}
}//jing biao sai pai xu
</code></pre>
<h3 id="完整代码">完整代码</h3>
<p>快速排序：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e4+5;
int n;
int a[maxn];
void qsort(int l,int r) {
	int m,n;
	int mid,p;
	m=l,n=r;
	mid=a[(l+r)/2];           
	do {
		while (a[m]&lt;mid) m++;  
		while (a[n]&gt;mid) n--;    
		if (m&lt;=n) {
			swap(a[m],a[n]);
			m++; 
			n--;           
		}
	} while (m&lt;=n);             
	if (m&lt;n) qsort(l,n);            
	if (m&lt;r) qsort(m,r);
}
int main() {
	freopen(&quot;kp.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;kp.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for (int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]);
	qsort(1,n);
	for (int i=1; i&lt;=n; i++) printf(&quot;%d &quot;,a[i]);	
	fclose(stdin);
	fclose(stdout);
	return 0;
}
</code></pre>
<h3 id="时间复杂度">时间复杂度</h3>
<figure data-type="image" tabindex="1"><img src="https://ericnth.cn/wp-content/uploads/2020/08/849589-20180402133438219-1946132192-1536x1038.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P6784 「EZEC-3」造房子]]></title>
        <id>https://zxh23682.github.io/post/ti-jie-p6784-ezec-3-zao-fang-zi/</id>
        <link href="https://zxh23682.github.io/post/ti-jie-p6784-ezec-3-zao-fang-zi/">
        </link>
        <updated>2020-11-15T06:57:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意：</h3>
<p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 块钱、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 材料和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 材料，造第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 层楼需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 材料与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 材料，每块钱都可以用来买 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 材料或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 材料，问最多可以造几层楼。</p>
<hr>
<h3 id="思路">思路：</h3>
<p>要求最多可以造几层楼，那么只要暴力枚举第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 层即可。</p>
<p>注意数据范围，要开 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">ull</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span></p>
<hr>
<h3 id="code">Code:</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef unsigned long long ull;
ull a,b,c;
ull ans;
int main() {
	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; //输入 
	if(a&gt;b) swap(a,b); //如果 a&gt;b 就交换 a,b 的值 
	for (ans=1;;ans++) { //无条件循环枚举每一层 
		if(a&lt;ans) { //如果 a&lt;ans 
			if(a+c &gt;= ans) {
				c-=ans-a;
				a=ans;
			}
			else break;
		}
		if(b&lt;ans) { //如果 b&lt;ans 
			if(b+c &gt;= ans) {
				c-=ans-b;
			    b = ans;
			}
			else break;
		}
		a-=ans, b-=ans;
	}
	cout&lt;&lt;ans-1; //注意输出的是 ans-1 
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【置顶】我的个人信息]]></title>
        <id>https://zxh23682.github.io/post/wo-de-ge-ren-xin-xi/</id>
        <link href="https://zxh23682.github.io/post/wo-de-ge-ren-xin-xi/">
        </link>
        <updated>2020-11-15T03:20:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="我的个人信息">我的个人信息：</h2>
<p>我的性别：男。</p>
<p>我的名字首字母：<code>zxh</code></p>
<p>我的学校：上海市民办华育中学。</p>
<p>我的邮箱：<code>hy23682@126.com</code></p>
<p>我的洛谷账号：<a href="https://www.luogu.com.cn/user/351320">zxh23682</a></p>
<p>我的<code>github</code>：<a href="https://github.com/zxh23682/">zxh23682</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF878B 【Teams Formation】]]></title>
        <id>https://zxh23682.github.io/post/ti-jie-cf878b-teams-formation/</id>
        <link href="https://zxh23682.github.io/post/ti-jie-cf878b-teams-formation/">
        </link>
        <updated>2020-11-15T03:03:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意：</h3>
<p>给出一个长为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的序列，将其重复 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 次，连续相等的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的个元素可以被消除，问最后剩余多少个元素。</p>
<h3 id="思路">思路：</h3>
<p>首先我们先考虑单个串，如果单个串中有恰好 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的倍数个连续相同字符，那么我们应该先将其消除，那么第一步我们遍历数组，这里我们需要用到一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>i</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">pair</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 数组,数组中前面存数值，后面存个数。</p>
<p>这样如果我们遍历到的数字和前一个相同也就是找到了连续相同的，我们只需要给顶部的元素的 <code>st[top].second+1</code>，如果发现和前一个元素不同说明已经不连续相同了，这时候我们再把这个数放进去，这样的好处就是我们 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>i</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">pair</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 数组中用一个数字和其个数代表了连续相等的串，这样我们只需要判断 <code>st[i].second%k</code> 是否等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 就可以。</p>
<p>这样对于初始串的处理就结束了，我们就得到的消去连续的后的单个串的个数我们记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">rec</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span></span></span></span>。</p>
<p>然后我们观察，发现对于每两个串相连，其实就是一个串的首尾相连把连续相同的k个消去，这样我们还是对一个串处理，我们继续处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>i</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">pair</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 数组。</p>
<p>用两个下标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 从两边向中间缩，如果两头数字相同并且，他们的个数之和恰好是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的倍数，那么这一堆全都可以消去，这样我们让 <code>l++，r++</code>，记录下消除的个数，一直到两头数字不能完全消除为止。</p>
<p>用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">while</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span> 循环实现，每个串消除的首尾总个数记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>c</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">rec2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord">2</span></span></span></span>，同时我们发现第一个串的首和最后一个串尾可能不会接触，那么我们可以确定一定会减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>c</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">rec2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord">2</span></span></span></span>。</p>
<p>接下来分两种情况讨论即可：</p>
<ul>
<li>
<p>只剩下了一种数字</p>
</li>
<li>
<p>剩下多种数字</p>
</li>
</ul>
<p>注意要开 <code>long long</code>。</p>
<h3 id="code">Code:</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
ll a[100005];
pair&lt;ll,ll&gt; st[100005];
ll top,n,m,k,l,r,rec,rec2;
ll ans;
int main() {
	scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;k,&amp;m);
	for(ll i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]);
	for(ll i=1; i&lt;=n; i++) {
		if(!top || st[top].first!=a[i]) st[++top]=make_pair(a[i],1);
		else st[top].second=(st[top].second + 1)%k;
		if(st[top].second==0) top--;
	}
	for(ll i=1; i&lt;=top; i++) rec += st[i].second;
	l=1,r=top;
	while(l&lt;r &amp;&amp; st[l].first==st[r].first &amp;&amp; (st[l].second+st[r].second)%k==0) {
		rec2 += st[l].second+st[r].second;
		l++;
		r--;
	}
	if(l==r) {
		if(st[l].second*m%k==0) ans -= rec2;
		ans += m*rec-rec2*(m-1)-(st[l].second*m/k*k);
	} else {
		if(st[l].first==st[r].first) rec2 += (st[l].second+st[r].second)/k*k;
		ans=m*rec-rec2*(m - 1);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P6833 【[Cnoi2020]雷雨】]]></title>
        <id>https://zxh23682.github.io/post/ti-jie-p6833-cnoi2020lei-yu/</id>
        <link href="https://zxh23682.github.io/post/ti-jie-p6833-cnoi2020lei-yu/">
        </link>
        <updated>2020-11-15T02:56:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="思路">思路</h3>
<p>可以想到，这题其实就是找一个点满足这个点到题目要求的三个点的最短路之和最小（去除重复部分），所以直接用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span><br>
求出三个点到每个点的最短路，然后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 扫描每个点找出满足上述条件的点即可。</p>
<p>注意：输入的矩阵第一行是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 然后递减，所以如果是从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 开始输入的需要把题目中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 替换。</p>
<p><strong>此题需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">long</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">long</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 。</strong></p>
<hr>
<h3 id="code">Code:</h3>
<pre><code class="language-cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int A = 1e3 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
bool vis[A][A];
int n, m, a, b, c;
ll dis[3][A][A], mapp[A][A];

struct node {
	int x, y;
	ll val;
	bool operator &lt; (const node &amp;b) const {
		return val &gt; b.val;
	}
};


inline void Dij(int sx, int sy, int tag) {
	priority_queue &lt;node&gt; Q;
	memset(dis[tag], inf, sizeof(dis[tag]));
	memset(vis, 0, sizeof(vis));
	dis[tag][sx][sy] = mapp[sx][sy];
	Q.push((node) {
		sx, sy, dis[tag][sx][sy]
	});
	while (!Q.empty()) {
		int x = Q.top().x, y = Q.top().y;
		Q.pop();
		if (vis[x][y]) continue;
		vis[x][y] = 1;
		for (int i=0; i&lt;4; i++) {
			int bx = x + dx[i], by = y + dy[i];
			if (bx &gt; n || bx &lt; 1 || by &gt; m || by &lt; 1) continue;
			if (dis[tag][bx][by] &gt; dis[tag][x][y] + mapp[bx][by]) {
				dis[tag][bx][by] = dis[tag][x][y] + 1ll * mapp[bx][by];
				Q.push((node) {
					bx, by, dis[tag][bx][by]
				});
			}
		}
	}
}

int main() {
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b&gt;&gt;c;
	for (int i=1; i&lt;=n; i++) for (int j=1; j&lt;=m; j++) cin&gt;&gt;mapp[i][j];
	Dij(1, a, 0);
	Dij(n, b, 1);
	Dij(n, c, 2);
	ll ans = 1e18;
	for (int i=1; i&lt;=n; i++) {
		for (int j=1; j&lt;=m; j++) {
			ans = min(ans, dis[0][i][j] + dis[1][i][j] + dis[2][i][j] - 2 * mapp[i][j]);
		}
	}
	cout&lt;&lt;ans;
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P6855 【「EZEC-4.5」走方格】]]></title>
        <id>https://zxh23682.github.io/post/ti-jie-p6855-ezec-45-zou-fang-ge/</id>
        <link href="https://zxh23682.github.io/post/ti-jie-p6855-ezec-45-zou-fang-ge/">
        </link>
        <updated>2020-11-15T02:50:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题意">题意：</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∗</mi></mrow><annotation encoding="application/x-tex">∗</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的网格，每个格子有一个数，可以选择一个位置变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。要求最小化最大权值和路径。</p>
<h3 id="思路">思路：</h3>
<p>考虑枚举哪个位置变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，一个位置变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 后我们将路径分为两种路径，一种是经过该点的路径，一种是不经过该点的路径。</p>
<p>我们预处理出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 的最大权和， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(n,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 的最大权和。然后我们发现如果不走 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 这个位置，那么一会走 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>−</mo><mo>&gt;</mo><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,y)-&gt;(i,y+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">i&lt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>；或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>−</mo><mo>&gt;</mo><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,j)-&gt;(x+1,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">j&lt;y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 计算这些走法的最大权值和即可。</p>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p>
<hr>
<h3 id="code">Code：</h3>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
ll n,m,a[2005][2005],f[2005][2005],g[2005][2005],ar[2005][2005],br[2005][2005];
int main() {
	cin&gt;&gt;n&gt;&gt;m;
	for(ll i=1; i&lt;=n; i++)
		for(ll j=1; j&lt;=m; j++) {
			cin&gt;&gt;a[i][j];
			f[i][j] = max(f[i-1][j],f[i][j-1])+a[i][j];
		}
	for(ll i=n; i&gt;=1; i--)
		for(ll j=m; j&gt;=1; j--) {
			g[i][j] = max(g[i+1][j],g[i][j+1])+a[i][j];
			ar[i][j] = f[i][j]+g[i+1][j];
			br[i][j] = f[i][j]+g[i][j+1];
		}
	ll ans=1e18;
	for(ll i=1; i&lt;=n; i++)
		for(ll j=1; j&lt;=m; j++) {
			ll z = max(f[i][j]+g[i][j]-2*a[i][j],max(ar[i][j-1],br[i-1][j]));
			ans = min(ans,z);
			if(j!=1) ar[i][j] = max(ar[i][j],ar[i][j-1]);
			if(i!=1) br[i][j] = max(br[i][j],br[i-1][j]);
		}
	cout&lt;&lt;ans;
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>